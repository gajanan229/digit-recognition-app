# -*- coding: utf-8 -*-
"""digit_recognition_model.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1N6ADKO7KBSZx1qCus-UDvICjmei89Ipv

## Importing Libraries


```
# This is formatted as code
```
"""

import numpy as np
from tensorflow import keras
from keras.models import Sequential
from keras.layers import Dense, Flatten
from keras.activations import linear, relu, sigmoid
import tensorflow as tf
import numpy as np
from tkinter import *
import tkinter as tk
import win32gui
from PIL import ImageGrab, Image
import PIL.ImageOps

"""## Import Data

"""

from keras.datasets import mnist

(x_train, y_train), (x_test, y_test) = mnist.load_data()
print(x_train.shape, y_train.shape)
print(x_test.shape, y_test.shape)

"""Prepping Data"""

# Reshaping the input data
x_train = x_train.reshape(x_train.shape[0], 28, 28, 1)
x_test = x_test.reshape(x_test.shape[0], 28, 28, 1)
# Encoding the labels
y_train = keras.utils.to_categorical(y_train, 10)
y_test = keras.utils.to_categorical(y_test, 10)
# Data type conversion and normalization
x_train = x_train.astype('float32')
x_test = x_test.astype('float32')
x_train /= 255
x_test /= 255
print('x_train shape:', x_train.shape)
print(x_train.shape[0], 'train samples')
print(x_test.shape[0], 'test samples')

"""## Defining and Training The Model"""

# Define the model
model = Sequential([
    Flatten(input_shape=(28, 28, 1)),
    Dense(128, activation='relu'),
    Dense(64, activation='relu'),
    Dense(10, activation='linear')
])

model.summary()

# Compile the model
model.compile(
              optimizer='adam',
              loss=tf.keras.losses.CategoricalCrossentropy(from_logits=True),
              metrics=['accuracy'])

# Train the model
hist = model.fit(x_train, y_train, epochs=12, batch_size=32, validation_split=0.2)

"""## Testing and Saving The Model"""

# Evaluate the model
test_loss, test_acc = model.evaluate(x_test, y_test)
print("Test Accuracy:", test_acc)

# Predict labels for test data
predictions = model.predict(x_test)
predicted_labels = np.argmax(predictions, axis=1)
true_labels = np.argmax(y_test, axis=1)

# Count the number of mistakes
num_mistakes = np.sum(predicted_labels != true_labels)
print("Number of mistakes:", num_mistakes)

def prediction(img):
    img = img.resize((28, 28))

    img = img.convert('L')
    img = PIL.ImageOps.invert(img)
    img = np.array(img)

    img = img.reshape(1, 28, 28, 1)
    img = img / 255.0
    img2 = img
    img2[0][0] = 0.0
    img2[0][1] = 0.0
    img2[0][:, :4, 0] = 0

    print(model.predict([img2]))
    res = model.predict([img2])[0]
    return np.argmax(res), max(res)


class App(tk.Tk):
    def __init__(self):
        tk.Tk.__init__(self)
        self.x = self.y = 0
        # Creating elements
        self.canvas = tk.Canvas(self, width=400, height=400, bg="white", cursor="cross")
        self.label = tk.Label(self, text="Thinking..", font=("Helvetica", 48))
        self.btn_classify = tk.Button(self, text="Recognise", command=self.classify_handwriting)
        self.clear_button = tk.Button(self, text="Clear", command=self.clear_all)
        self.canvas.grid(row=0, column=0, pady=2, sticky=W, )
        self.label.grid(row=0, column=1, pady=2, padx=2)
        self.btn_classify.grid(row=1, column=1, pady=2, padx=2)
        self.clear_button.grid(row=1, column=0, pady=2)
        self.canvas.bind("<B1-Motion>", self.draw_lines)

    def clear_all(self):
        self.canvas.delete("all")

    def classify_handwriting(self):
        HWND = self.canvas.winfo_id()
        rect = win32gui.GetWindowRect(HWND)
        im = ImageGrab.grab(rect)
        digit, acc = prediction(im)
        self.label.configure(text=str(digit) + ', ' + str(int(acc * 100)) + '%')

    def draw_lines(self, event):
        self.x = event.x
        self.y = event.y
        r = 8
        self.canvas.create_oval(self.x - r, self.y - r, self.x + r, self.y + r, fill='black')


app = App()
mainloop()
